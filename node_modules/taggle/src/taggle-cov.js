
// instrument by jscoverage, do not modifly this file
(function (file, lines, conds, source) {
  var BASE;
  if (typeof global === 'object') {
    BASE = global;
  } else if (typeof window === 'object') {
    BASE = window;
  } else {
    throw new Error('[jscoverage] unknow ENV!');
  }
  if (BASE._$jscoverage) {
    BASE._$jscmd(file, 'init', lines, conds, source);
    return;
  }
  var cov = {};
  /**
   * jsc(file, 'init', lines, condtions)
   * jsc(file, 'line', lineNum)
   * jsc(file, 'cond', lineNum, expr, start, offset)
   */
  function jscmd(file, type, line, express, start, offset) {
    var storage;
    switch (type) {
      case 'init':
        if(cov[file]){
          storage = cov[file];
        } else {
          storage = [];
          for (var i = 0; i < line.length; i ++) {
            storage[line[i]] = 0;
          }
          var condition = express;
          var source = start;
          storage.condition = condition;
          storage.source = source;
        }
        cov[file] = storage;
        break;
      case 'line':
        storage = cov[file];
        storage[line] ++;
        break;
      case 'cond':
        storage = cov[file];
        storage.condition[line] ++;
        return express;
    }
  }

  BASE._$jscoverage = cov;
  BASE._$jscmd = jscmd;
  jscmd(file, 'init', lines, conds, source);
})('src/taggle.js', [11,11,13,100,642,101,517,521,525,529,533,537,555,576,124,128,132,136,137,138,145,148,149,151,152,153,154,161,163,164,165,166,167,187,188,189,190,191,192,171,172,177,178,179,180,183,199,203,204,206,207,200,215,220,222,223,224,230,231,233,228,254,243,247,251,262,271,272,273,274,276,278,279,280,281,268,288,290,298,299,300,301,304,308,317,325,344,330,332,341,339,353,359,356,368,371,375,383,384,387,391,400,402,404,407,408,412,421,423,425,434,436,440,443,451,457,462,467,469,470,471,472,474,475,477,479,480,481,483,484,485,487,488,490,499,506,507,509,511,512,514,503,518,522,526,530,534,538,552,541,547,556,572,569,561,562,566,584,594,582,586,589,601,599,609,613,614,619,622,625,630,635,638], {"123_12_20":0,"127_12_27":0,"131_12_22":0,"152_28_21":0,"152_53_17":0,"153_28_22":0,"153_54_18":0,"169_16_20":0,"176_16_11":0,"182_20_21":0,"227_16_6":0,"242_16_5":0,"246_16_44":0,"246_16_25":0,"246_45_15":0,"250_16_72":0,"250_16_27":0,"250_47_41":0,"262_49_18":0,"262_70_32":0,"267_16_13":0,"288_16_1":0,"288_21_12":0,"296_16_59":0,"296_16_45":0,"296_65_10":0,"296_16_18":0,"296_38_23":0,"297_20_41":0,"307_21_41":0,"317_33_5":0,"329_16_26":0,"337_16_11":0,"338_20_26":0,"355_16_37":0,"370_16_59":0,"374_16_11":0,"386_16_58":0,"390_16_33":0,"390_16_18":0,"390_38_11":0,"400_16_1":0,"400_21_12":0,"406_16_40":0,"406_16_18":0,"406_38_18":0,"411_16_17":0,"421_16_1":0,"421_21_12":0,"434_16_1":0,"434_21_12":0,"439_16_16":0,"456_16_54":0,"502_16_33":0,"507_19_14":0,"507_37_16":0,"540_16_24":0,"544_16_6":0,"546_24_27":0,"560_20_24":0,"565_20_13":0,"565_20_5":0,"565_29_4":0,"581_12_20":0,"588_20_26":0,"598_12_13":0,"609_56_13":0,"609_72_2":0,"618_12_24":0,"621_17_19":0,"634_12_46":0,"634_12_18":0,"634_34_24":0}, ["/*jshint scripturl:true, smarttabs:true */",""," /*!"," * @author Sean Coker <sean@seancoker.com>"," * @version 1.5.0"," * @url http://sean.is/poppin/tags"," * @license MIT"," * @description Taggle is a dependency-less tagging library"," */","",";(function(window, document, undefined) {","","    var DEFAULTS = {","","        /**","         * Class names to be added on each tag entered","         * @type {String}","         */","        additionalTagClasses:   '',","","        /**","         * Allow duplicate tags to be entered in the field?","         * @type {Boolean}","         */","        allowDuplicates:        false,","","        /**","         * Class name that will be added onto duplicate existant tag","         * @type {String}","         */","        duplicateTagClass:      '',","","        /**","         * Class added to the container div when focused","         * @type {String}","         */","        containerFocusClass:    'active',","","        /**","         * Name added to the hidden inputs within each tag","         * @type {String}","         */","        hiddenInputName:        'taggles[]',","","        /**","         * Tags that should be preloaded in the div on load","         * @type {Array}","         */","        tags:                   [],","","        /**","         * Tags that the user will be restricted to","         * @type {Array}","         */","        allowedTags:            [],","","        /**","         * If within a form, you can specify the tab index flow","         * @type {Number}","         */","        tabIndex:               1,","","        /**","         * Placeholder string to be placed in an empty taggle field","         * @type {String}","         */","        placeholder:            'Enter tags...',","","        /**","         * Keycodes that will add a tag","         * @type {Array}","         */","        submitKeys:             [],","","        /**","         * Function hook called when a tag is added","         * @param  {Event} event Event triggered when tag was added","         * @param  {String} tag The tag added","         */","        onTagAdd:               function() {},","","        /**","         * Function hook called when a tag is removed","         * @param  {Event} event Event triggered when tag was removed","         * @param  {String} tag The tag removed","         */","        onTagRemove:            function() {}","    },","","    BACKSPACE = 8,","    COMMA = 188,","    TAB = 9,","    ENTER = 13;","","    /**","     * Constructor","     * @param {Mixed} el ID of an element or the actual element","     * @param {Object} options","     */","    var Taggle = function(el, options) {","        var self = this,","            settings = _extend({}, DEFAULTS, options),","            measurements = {","                container: {","                    rect: null,","                    style: null,","                    padding: null","                }","            },","","            container = el,","            tag = {","                values: [],","                elements: []","            },","","            list = document.createElement('ul'),","            input_li = document.createElement('li'),","            input = document.createElement('input'),","            sizer = document.createElement('div'),","            placeholder;","","        if (settings.placeholder) {","            placeholder = document.createElement('span');","        }","","        if (!settings.submitKeys.length) {","            settings.submitKeys = [COMMA, TAB, ENTER];","        }","","        if (typeof el === 'string') {","            container = document.getElementById(el);","        }","","        function _init() {","            _getMeasurements();","            _setupTextarea();","            _attachEvents();","        }","","        /**","         * Gets all the layout measurements up front","         */","        function _getMeasurements() {","            var style,","                lpad, rpad;","","            measurements.container.rect = container.getBoundingClientRect();","            measurements.container.style = window.getComputedStyle(container);","","            style = measurements.container.style;","            lpad = parseInt(style['padding-left'] || style.paddingLeft, 10);","            rpad = parseInt(style['padding-right'] || style.paddingRight, 10);","            measurements.container.padding =  lpad + rpad;","        }","","        /**","         * Setup the div container for tags to be entered","         */","        function _setupTextarea() {","            var font_size;","","            list.className = 'taggle_list';","            input.type = 'text';","            input.className = 'taggle_input';","            input.tabIndex = settings.tabIndex;","            sizer.className = 'taggle_sizer';","","            if (settings.tags.length) {","                for (var i = 0, len = settings.tags.length; i < len; i++) {","                    var tag = _createTag(settings.tags[i]);","                    list.appendChild(tag);","                }","            }","","            if (placeholder) {","                placeholder.style.opacity = 0;","                placeholder.classList.add('taggle_placeholder');","                container.appendChild(placeholder);","                _setText(placeholder, settings.placeholder);","","                if (!settings.tags.length) {","                    placeholder.style.opacity = 1;","                }","            }","","            input_li.appendChild(input);","            list.appendChild(input_li);","            container.appendChild(list);","            container.appendChild(sizer);","            font_size = window.getComputedStyle(input).fontSize;","            sizer.style.fontSize = font_size;","        }","","        /**","         * Attaches neccessary events","         */","        function _attachEvents() {","            _on(container, 'click', function() {","                input.focus();","            });","","            input.onfocus = _focusInput;","            input.onblur = _blurInput;","","            _on(input, 'keydown', _keydownEvents);","            _on(input, 'keyup', _keyupEvents);","        }","","        /**","         * Resizes the hidden input where user types to fill in the","         * width of the div","         */","        function _fixInputWidth() {","            var width,","                input_rect, rect,","                left_pos,","                padding;","            //reset width incase we've broken to the next line on a backspace erase","            _setInputWidth();","","            input_rect = input.getBoundingClientRect();","            rect = measurements.container.rect;","            width = ~~rect.width;","            // Could probably just use right - left all the time","            // but eh, this check is mostly for IE8","            if (!width) {","                width = ~~rect.right - ~~rect.left;","            }","            left_pos = ~~input_rect.left - ~~rect.left;","            padding = measurements.container.padding;","","            _setInputWidth(width - left_pos - padding);","        }","","        /**","         * Returns whether or not the specified tag text can be added","         * @param  {String} text tag value","         * @return {Boolean}","         */","        function _canAdd(text) {","            if (!text) {","                return false;","            }","","            if (!settings.allowDuplicates && _hasDupes(text)) {","                return false;","            }","","            if (settings.allowedTags.length && settings.allowedTags.indexOf(text) === -1) {","                return false;","            }","","            return true;","        }","","        /**","         * Appends tag with its corresponding input to the list","         * @param  {String} tag","         */","        function _add(e, text) {","            var val = typeof text === 'string' ? text.toLowerCase() : _trim(input.value.toLowerCase()),","                li,","                lis,","                last_li;","","            if (!_canAdd(val)) {","                return;","            }","","            li = _createTag(val);","            lis = list.querySelectorAll('li');","            last_li = lis[lis.length - 1];","            list.insertBefore(li, last_li);","","            settings.onTagAdd(e, val);","","            input.value = '';","            _setInputWidth();","            _fixInputWidth();","            _focusInput();","        }","","        /**","         * Removes last tag if it has already been probed","         */","        function _checkLastTag(e) {","            e = e || window.event;","","            var taggles = container.querySelectorAll('.taggle'),","                last_taggle = taggles[taggles.length - 1],","                hot_class = 'taggle_hot',","                held_down = input.classList.contains('taggle_back');","","            //prevent holding backspace from deleting all tags","            if (input.value === '' && e.keyCode === BACKSPACE && !held_down) {","                if (last_taggle.classList.contains(hot_class)) {","                    input.classList.add('taggle_back');","                    _remove(last_taggle, e);","                    _fixInputWidth();","                    _focusInput();","                }","                else {","                    last_taggle.classList.add(hot_class);","                }","            }","            else if (last_taggle.classList.contains(hot_class)) {","                last_taggle.classList.remove(hot_class);","            }","        }","","        /**","         * Setter for the hidden input.","         * @param {Number} width","         */","        function _setInputWidth(width) {","            input.style.width = (width || 10) + 'px';","        }","","        /**","         * Checks global tags array if provided tag exists","         * @param  {String} tag","         */","        function _hasDupes(text) {","            var needle = tag.values.indexOf(text),","                taggle_list = container.querySelector('.taggle_list'),","                dupes;","","            if (settings.duplicateTagClass) {","                dupes = taggle_list.querySelectorAll('.' + settings.duplicateTagClass);","                for (var i = 0, len = dupes.length; i < len; i++) {","                    dupes[i].classList.remove(settings.duplicateTagClass);","                }","            }","","            //if found","            if (needle > -1) {","                if (settings.duplicateTagClass) {","                    taggle_list.childNodes[needle].classList.add(settings.duplicateTagClass);","                }","                return true;","            }","","            return false;","        }","","        /**","         * Checks whether or not the key pressed is acceptable","         * @param  {Number}  key code","         * @return {Boolean}","         */","        function _isConfirmKey(key) {","            var confirm_key = false;","","            if (settings.submitKeys.indexOf(key) > -1) {","                confirm_key = true;","            }","","            return confirm_key;","        }","","        //event handlers","","        /**","         * Handles focus state of div container.","         */","        function _focusInput() {","            _fixInputWidth();","","            if (!container.classList.contains(settings.containerFocusClass)) {","                container.classList.add(settings.containerFocusClass);","            }","","            if (placeholder) {","                placeholder.style.opacity = 0;","            }","        }","","        /**","         * Sets state of container when blurred","         */","        function _blurInput() {","            input.value = '';","            _setInputWidth();","","            if (container.classList.contains(settings.containerFocusClass)) {","                container.classList.remove(settings.containerFocusClass);","            }","","            if (!tag.values.length && placeholder) {","                placeholder.style.opacity = 1;","            }","        }","","        /**","         * Runs all the events that need to run on keydown","         * @param  {Event} e","         */","         function _keydownEvents(e) {","            e = e || window.event;","","            var key = e.keyCode;","","            _listenForEndOfContainer();","","            if (_isConfirmKey(key) && input.value !== '') {","                _confirmValidTagEvent(e);","                return;","            }","","            if (tag.values.length) {","                _checkLastTag(e);","            }","        }","","        /**","         * Runs all the events that need to run on keyup","         * @param  {Event} e","         */","        function _keyupEvents(e) {","            e = e || window.event;","","            input.classList.remove('taggle_back');","","            _setText(sizer, input.value);","        }","","        /**","         * Confirms the inputted value to be converted to a tag","         * @param  {Event} e","         * @return {Boolean}","         */","        function _confirmValidTagEvent(e) {","            e = e || window.event;","","            _add(e);","","            //prevents from jumping out of textarea","            if (e.preventDefault) {","                e.preventDefault();","            }","            else {","                e.returnValue = false;","            }","        }","","        /**","         * Approximates when the hidden input should break to the next line","         */","        function _listenForEndOfContainer() {","            var width = sizer.getBoundingClientRect().width,","                max = measurements.container.rect.width - measurements.container.padding,","                size = parseInt(sizer.style.fontSize, 10);","","            //1.5 just seems to be a good multiplier here","            if (width + (size * 1.5) > parseInt(input.style.width, 10)) {","                input.style.width = max + 'px';","            }","        }","","        function _createTag(text) {","            var li = document.createElement('li'),","                close = document.createElement('a'),","                hidden = document.createElement('input'),","                span = document.createElement('span');","","            text = text.toLowerCase();","","            close.href = 'javascript:void(0)';","            close.innerHTML = '&times;';","            close.className = 'close';","            close.onclick = _remove.bind(null, close);","","            _setText(span, text);","            span.className = 'taggle_text';","","            li.className = 'taggle ' + settings.additionalTagClasses;","","            hidden.type = 'hidden';","            hidden.value = text;","            hidden.name = settings.hiddenInputName;","","            li.appendChild(span);","            li.appendChild(close);","            li.appendChild(hidden);","","            tag.values.push(text);","            tag.elements.push(li);","","            return li;","        }","","        /**","         * Removes tag from the tags collection","         * @param  {li} li List item to remove","         * @param  {Event} e","         */","        function _remove(li, e) {","            var span,","                text;","","            if (li.tagName.toLowerCase() !== 'li') {","                li = li.parentNode;","            }","","            span = li.querySelector('.taggle_text');","            text = span.innerText || span.textContent;","","            settings.onTagRemove(e, text);","","            li.parentNode.removeChild(li);","            _removeFromTheTags(li, tag);","","            _focusInput();","        }","","        self.getTags = function() {","            return tag;","        };","","        self.getTagElements = function() {","            return tag.elements;","        };","","        self.getTagValues = function() {","            return tag.values;","        };","","        self.getInput = function() {","            return input;","        };","","        self.getContainer = function() {","            return container;","        };","","        self.add = function(text) {","            var is_arr = _isArray(text);","","            if (typeof text === 'string') {","                return _add(null, text);","            }","","            if (is_arr) {","                for (var i = 0, len = text.length; i < len; i++) {","                    if (typeof text[i] === 'string') {","                        _add(null, text[i]);","                    }","                }","            }","","            return self;","        };","","        self.remove = function(text, all) {","            var len = tag.values.length - 1,","                found = false;","","            while (len > -1) {","                if (tag.values[len] === text) {","                    found = true;","                    _remove(tag.elements[len]);","                }","","                if (found && !all) {","                    break;","                }","","                len--;","            }","","            return self;","        };","","        // Bang bang bang skeet skeet","        _init();","    };","","","    function _extend() {","        if (arguments.length < 2) {","            return;","        }","        var master = arguments[0];","        for (var i = 1, l = arguments.length; i < l; i++) {","            var object = arguments[i];","            for (var key in object) {","                if (object.hasOwnProperty(key)) {","                    master[key] = object[key];","                }","            }","        }","","        return master;","    }","","    function _isArray(arr) {","        if (Array.isArray) {","            return Array.isArray(arr);","        }","        return Object.prototype.toString.call(arr) === '[object Array]';","    }","","    /**","     * Grabs the text from the li item and removes it from global array","     * @param  {Element} el","     */","    function _removeFromTheTags(el, tag) {","        var elem = (el.tagName.toLowerCase() === 'a') ? el.parentNode : el,","            index = tag.elements.indexOf(elem);","","        // Going to assume the indicies match for now","        tag.elements.splice(index, 1);","        tag.values.splice(index, 1);","    }","","    function _on(element, eventName, handler) {","        if (element.addEventListener) {","            element.addEventListener(eventName, handler, false);","        }","        else if (element.attachEvent) {","            element.attachEvent('on' + eventName, handler);","        }","        else {","            element['on' + eventName] = handler;","        }","    }","","    function _trim(str) {","        return str.replace(/^\\s+|\\s+$/g, '');","    }","","    function _setText(el, text) {","        if (window.attachEvent && !window.addEventListener) { // <= IE8","            el.innerText = text;","        }","        else {","            el.textContent = text;","        }","    }","","    window.Taggle = Taggle;","","}(window, document));",""]);
/*jshint scripturl:true, smarttabs:true */
/*!
 * @author Sean Coker <sean@seancoker.com>
 * @version 1.5.0
 * @url http://sean.is/poppin/tags
 * @license MIT
 * @description Taggle is a dependency-less tagging library
 */
_$jscmd("src/taggle.js", "line", 11);

_$jscmd("src/taggle.js", "line", 11);

(function(window, document, undefined) {
    _$jscmd("src/taggle.js", "line", 13);
    var DEFAULTS = {
        /**
         * Class names to be added on each tag entered
         * @type {String}
         */
        additionalTagClasses: "",
        /**
         * Allow duplicate tags to be entered in the field?
         * @type {Boolean}
         */
        allowDuplicates: false,
        /**
         * Class name that will be added onto duplicate existant tag
         * @type {String}
         */
        duplicateTagClass: "",
        /**
         * Class added to the container div when focused
         * @type {String}
         */
        containerFocusClass: "active",
        /**
         * Name added to the hidden inputs within each tag
         * @type {String}
         */
        hiddenInputName: "taggles[]",
        /**
         * Tags that should be preloaded in the div on load
         * @type {Array}
         */
        tags: [],
        /**
         * Tags that the user will be restricted to
         * @type {Array}
         */
        allowedTags: [],
        /**
         * If within a form, you can specify the tab index flow
         * @type {Number}
         */
        tabIndex: 1,
        /**
         * Placeholder string to be placed in an empty taggle field
         * @type {String}
         */
        placeholder: "Enter tags...",
        /**
         * Keycodes that will add a tag
         * @type {Array}
         */
        submitKeys: [],
        /**
         * Function hook called when a tag is added
         * @param  {Event} event Event triggered when tag was added
         * @param  {String} tag The tag added
         */
        onTagAdd: function() {},
        /**
         * Function hook called when a tag is removed
         * @param  {Event} event Event triggered when tag was removed
         * @param  {String} tag The tag removed
         */
        onTagRemove: function() {}
    }, BACKSPACE = 8, COMMA = 188, TAB = 9, ENTER = 13;
    _$jscmd("src/taggle.js", "line", 100);
    /**
     * Constructor
     * @param {Mixed} el ID of an element or the actual element
     * @param {Object} options
     */
    var Taggle = function(el, options) {
        _$jscmd("src/taggle.js", "line", 101);
        var self = this, settings = _extend({}, DEFAULTS, options), measurements = {
            container: {
                rect: null,
                style: null,
                padding: null
            }
        }, container = el, tag = {
            values: [],
            elements: []
        }, list = document.createElement("ul"), input_li = document.createElement("li"), input = document.createElement("input"), sizer = document.createElement("div"), placeholder;
        if (_$jscmd("src/taggle.js", "cond", "123_12_20", settings.placeholder)) {
            _$jscmd("src/taggle.js", "line", 124);
            placeholder = document.createElement("span");
        }
        if (_$jscmd("src/taggle.js", "cond", "127_12_27", !settings.submitKeys.length)) {
            _$jscmd("src/taggle.js", "line", 128);
            settings.submitKeys = [ COMMA, TAB, ENTER ];
        }
        if (_$jscmd("src/taggle.js", "cond", "131_12_22", typeof el === "string")) {
            _$jscmd("src/taggle.js", "line", 132);
            container = document.getElementById(el);
        }
        function _init() {
            _$jscmd("src/taggle.js", "line", 136);
            _getMeasurements();
            _$jscmd("src/taggle.js", "line", 137);
            _setupTextarea();
            _$jscmd("src/taggle.js", "line", 138);
            _attachEvents();
        }
        /**
         * Gets all the layout measurements up front
         */
        function _getMeasurements() {
            _$jscmd("src/taggle.js", "line", 145);
            var style, lpad, rpad;
            _$jscmd("src/taggle.js", "line", 148);
            measurements.container.rect = container.getBoundingClientRect();
            _$jscmd("src/taggle.js", "line", 149);
            measurements.container.style = window.getComputedStyle(container);
            _$jscmd("src/taggle.js", "line", 151);
            style = measurements.container.style;
            _$jscmd("src/taggle.js", "line", 152);
            lpad = parseInt(_$jscmd("src/taggle.js", "cond", "152_28_21", style["padding-left"]) || _$jscmd("src/taggle.js", "cond", "152_53_17", style.paddingLeft), 10);
            _$jscmd("src/taggle.js", "line", 153);
            rpad = parseInt(_$jscmd("src/taggle.js", "cond", "153_28_22", style["padding-right"]) || _$jscmd("src/taggle.js", "cond", "153_54_18", style.paddingRight), 10);
            _$jscmd("src/taggle.js", "line", 154);
            measurements.container.padding = lpad + rpad;
        }
        /**
         * Setup the div container for tags to be entered
         */
        function _setupTextarea() {
            _$jscmd("src/taggle.js", "line", 161);
            var font_size;
            _$jscmd("src/taggle.js", "line", 163);
            list.className = "taggle_list";
            _$jscmd("src/taggle.js", "line", 164);
            input.type = "text";
            _$jscmd("src/taggle.js", "line", 165);
            input.className = "taggle_input";
            _$jscmd("src/taggle.js", "line", 166);
            input.tabIndex = settings.tabIndex;
            _$jscmd("src/taggle.js", "line", 167);
            sizer.className = "taggle_sizer";
            if (_$jscmd("src/taggle.js", "cond", "169_16_20", settings.tags.length)) {
                for (var i = 0, len = settings.tags.length; i < len; i++) {
                    _$jscmd("src/taggle.js", "line", 171);
                    var tag = _createTag(settings.tags[i]);
                    _$jscmd("src/taggle.js", "line", 172);
                    list.appendChild(tag);
                }
            }
            if (_$jscmd("src/taggle.js", "cond", "176_16_11", placeholder)) {
                _$jscmd("src/taggle.js", "line", 177);
                placeholder.style.opacity = 0;
                _$jscmd("src/taggle.js", "line", 178);
                placeholder.classList.add("taggle_placeholder");
                _$jscmd("src/taggle.js", "line", 179);
                container.appendChild(placeholder);
                _$jscmd("src/taggle.js", "line", 180);
                _setText(placeholder, settings.placeholder);
                if (_$jscmd("src/taggle.js", "cond", "182_20_21", !settings.tags.length)) {
                    _$jscmd("src/taggle.js", "line", 183);
                    placeholder.style.opacity = 1;
                }
            }
            _$jscmd("src/taggle.js", "line", 187);
            input_li.appendChild(input);
            _$jscmd("src/taggle.js", "line", 188);
            list.appendChild(input_li);
            _$jscmd("src/taggle.js", "line", 189);
            container.appendChild(list);
            _$jscmd("src/taggle.js", "line", 190);
            container.appendChild(sizer);
            _$jscmd("src/taggle.js", "line", 191);
            font_size = window.getComputedStyle(input).fontSize;
            _$jscmd("src/taggle.js", "line", 192);
            sizer.style.fontSize = font_size;
        }
        /**
         * Attaches neccessary events
         */
        function _attachEvents() {
            _$jscmd("src/taggle.js", "line", 199);
            _on(container, "click", function() {
                _$jscmd("src/taggle.js", "line", 200);
                input.focus();
            });
            _$jscmd("src/taggle.js", "line", 203);
            input.onfocus = _focusInput;
            _$jscmd("src/taggle.js", "line", 204);
            input.onblur = _blurInput;
            _$jscmd("src/taggle.js", "line", 206);
            _on(input, "keydown", _keydownEvents);
            _$jscmd("src/taggle.js", "line", 207);
            _on(input, "keyup", _keyupEvents);
        }
        /**
         * Resizes the hidden input where user types to fill in the
         * width of the div
         */
        function _fixInputWidth() {
            _$jscmd("src/taggle.js", "line", 215);
            var width, input_rect, rect, left_pos, padding;
            _$jscmd("src/taggle.js", "line", 220);
            //reset width incase we've broken to the next line on a backspace erase
            _setInputWidth();
            _$jscmd("src/taggle.js", "line", 222);
            input_rect = input.getBoundingClientRect();
            _$jscmd("src/taggle.js", "line", 223);
            rect = measurements.container.rect;
            _$jscmd("src/taggle.js", "line", 224);
            width = ~~rect.width;
            // Could probably just use right - left all the time
            // but eh, this check is mostly for IE8
            if (_$jscmd("src/taggle.js", "cond", "227_16_6", !width)) {
                _$jscmd("src/taggle.js", "line", 228);
                width = ~~rect.right - ~~rect.left;
            }
            _$jscmd("src/taggle.js", "line", 230);
            left_pos = ~~input_rect.left - ~~rect.left;
            _$jscmd("src/taggle.js", "line", 231);
            padding = measurements.container.padding;
            _$jscmd("src/taggle.js", "line", 233);
            _setInputWidth(width - left_pos - padding);
        }
        /**
         * Returns whether or not the specified tag text can be added
         * @param  {String} text tag value
         * @return {Boolean}
         */
        function _canAdd(text) {
            if (_$jscmd("src/taggle.js", "cond", "242_16_5", !text)) {
                _$jscmd("src/taggle.js", "line", 243);
                return false;
            }
            if (_$jscmd("src/taggle.js", "cond", "246_16_44", _$jscmd("src/taggle.js", "cond", "246_16_25", !settings.allowDuplicates) && _$jscmd("src/taggle.js", "cond", "246_45_15", _hasDupes(text)))) {
                _$jscmd("src/taggle.js", "line", 247);
                return false;
            }
            if (_$jscmd("src/taggle.js", "cond", "250_16_72", _$jscmd("src/taggle.js", "cond", "250_16_27", settings.allowedTags.length) && _$jscmd("src/taggle.js", "cond", "250_47_41", settings.allowedTags.indexOf(text) === -1))) {
                _$jscmd("src/taggle.js", "line", 251);
                return false;
            }
            _$jscmd("src/taggle.js", "line", 254);
            return true;
        }
        /**
         * Appends tag with its corresponding input to the list
         * @param  {String} tag
         */
        function _add(e, text) {
            _$jscmd("src/taggle.js", "line", 262);
            var val = typeof text === "string" ? _$jscmd("src/taggle.js", "cond", "262_49_18", text.toLowerCase()) : _$jscmd("src/taggle.js", "cond", "262_70_32", _trim(input.value.toLowerCase())), li, lis, last_li;
            if (_$jscmd("src/taggle.js", "cond", "267_16_13", !_canAdd(val))) {
                _$jscmd("src/taggle.js", "line", 268);
                return;
            }
            _$jscmd("src/taggle.js", "line", 271);
            li = _createTag(val);
            _$jscmd("src/taggle.js", "line", 272);
            lis = list.querySelectorAll("li");
            _$jscmd("src/taggle.js", "line", 273);
            last_li = lis[lis.length - 1];
            _$jscmd("src/taggle.js", "line", 274);
            list.insertBefore(li, last_li);
            _$jscmd("src/taggle.js", "line", 276);
            settings.onTagAdd(e, val);
            _$jscmd("src/taggle.js", "line", 278);
            input.value = "";
            _$jscmd("src/taggle.js", "line", 279);
            _setInputWidth();
            _$jscmd("src/taggle.js", "line", 280);
            _fixInputWidth();
            _$jscmd("src/taggle.js", "line", 281);
            _focusInput();
        }
        /**
         * Removes last tag if it has already been probed
         */
        function _checkLastTag(e) {
            _$jscmd("src/taggle.js", "line", 288);
            e = _$jscmd("src/taggle.js", "cond", "288_16_1", e) || _$jscmd("src/taggle.js", "cond", "288_21_12", window.event);
            _$jscmd("src/taggle.js", "line", 290);
            var taggles = container.querySelectorAll(".taggle"), last_taggle = taggles[taggles.length - 1], hot_class = "taggle_hot", held_down = input.classList.contains("taggle_back");
            //prevent holding backspace from deleting all tags
            if (_$jscmd("src/taggle.js", "cond", "296_16_59", _$jscmd("src/taggle.js", "cond", "296_16_45", _$jscmd("src/taggle.js", "cond", "296_16_18", input.value === "") && _$jscmd("src/taggle.js", "cond", "296_38_23", e.keyCode === BACKSPACE)) && _$jscmd("src/taggle.js", "cond", "296_65_10", !held_down))) {
                if (_$jscmd("src/taggle.js", "cond", "297_20_41", last_taggle.classList.contains(hot_class))) {
                    _$jscmd("src/taggle.js", "line", 298);
                    input.classList.add("taggle_back");
                    _$jscmd("src/taggle.js", "line", 299);
                    _remove(last_taggle, e);
                    _$jscmd("src/taggle.js", "line", 300);
                    _fixInputWidth();
                    _$jscmd("src/taggle.js", "line", 301);
                    _focusInput();
                } else {
                    _$jscmd("src/taggle.js", "line", 304);
                    last_taggle.classList.add(hot_class);
                }
            } else if (_$jscmd("src/taggle.js", "cond", "307_21_41", last_taggle.classList.contains(hot_class))) {
                _$jscmd("src/taggle.js", "line", 308);
                last_taggle.classList.remove(hot_class);
            }
        }
        /**
         * Setter for the hidden input.
         * @param {Number} width
         */
        function _setInputWidth(width) {
            _$jscmd("src/taggle.js", "line", 317);
            input.style.width = (_$jscmd("src/taggle.js", "cond", "317_33_5", width) || 10) + "px";
        }
        /**
         * Checks global tags array if provided tag exists
         * @param  {String} tag
         */
        function _hasDupes(text) {
            _$jscmd("src/taggle.js", "line", 325);
            var needle = tag.values.indexOf(text), taggle_list = container.querySelector(".taggle_list"), dupes;
            if (_$jscmd("src/taggle.js", "cond", "329_16_26", settings.duplicateTagClass)) {
                _$jscmd("src/taggle.js", "line", 330);
                dupes = taggle_list.querySelectorAll("." + settings.duplicateTagClass);
                for (var i = 0, len = dupes.length; i < len; i++) {
                    _$jscmd("src/taggle.js", "line", 332);
                    dupes[i].classList.remove(settings.duplicateTagClass);
                }
            }
            //if found
            if (_$jscmd("src/taggle.js", "cond", "337_16_11", needle > -1)) {
                if (_$jscmd("src/taggle.js", "cond", "338_20_26", settings.duplicateTagClass)) {
                    _$jscmd("src/taggle.js", "line", 339);
                    taggle_list.childNodes[needle].classList.add(settings.duplicateTagClass);
                }
                _$jscmd("src/taggle.js", "line", 341);
                return true;
            }
            _$jscmd("src/taggle.js", "line", 344);
            return false;
        }
        /**
         * Checks whether or not the key pressed is acceptable
         * @param  {Number}  key code
         * @return {Boolean}
         */
        function _isConfirmKey(key) {
            _$jscmd("src/taggle.js", "line", 353);
            var confirm_key = false;
            if (_$jscmd("src/taggle.js", "cond", "355_16_37", settings.submitKeys.indexOf(key) > -1)) {
                _$jscmd("src/taggle.js", "line", 356);
                confirm_key = true;
            }
            _$jscmd("src/taggle.js", "line", 359);
            return confirm_key;
        }
        //event handlers
        /**
         * Handles focus state of div container.
         */
        function _focusInput() {
            _$jscmd("src/taggle.js", "line", 368);
            _fixInputWidth();
            if (_$jscmd("src/taggle.js", "cond", "370_16_59", !container.classList.contains(settings.containerFocusClass))) {
                _$jscmd("src/taggle.js", "line", 371);
                container.classList.add(settings.containerFocusClass);
            }
            if (_$jscmd("src/taggle.js", "cond", "374_16_11", placeholder)) {
                _$jscmd("src/taggle.js", "line", 375);
                placeholder.style.opacity = 0;
            }
        }
        /**
         * Sets state of container when blurred
         */
        function _blurInput() {
            _$jscmd("src/taggle.js", "line", 383);
            input.value = "";
            _$jscmd("src/taggle.js", "line", 384);
            _setInputWidth();
            if (_$jscmd("src/taggle.js", "cond", "386_16_58", container.classList.contains(settings.containerFocusClass))) {
                _$jscmd("src/taggle.js", "line", 387);
                container.classList.remove(settings.containerFocusClass);
            }
            if (_$jscmd("src/taggle.js", "cond", "390_16_33", _$jscmd("src/taggle.js", "cond", "390_16_18", !tag.values.length) && _$jscmd("src/taggle.js", "cond", "390_38_11", placeholder))) {
                _$jscmd("src/taggle.js", "line", 391);
                placeholder.style.opacity = 1;
            }
        }
        /**
         * Runs all the events that need to run on keydown
         * @param  {Event} e
         */
        function _keydownEvents(e) {
            _$jscmd("src/taggle.js", "line", 400);
            e = _$jscmd("src/taggle.js", "cond", "400_16_1", e) || _$jscmd("src/taggle.js", "cond", "400_21_12", window.event);
            _$jscmd("src/taggle.js", "line", 402);
            var key = e.keyCode;
            _$jscmd("src/taggle.js", "line", 404);
            _listenForEndOfContainer();
            if (_$jscmd("src/taggle.js", "cond", "406_16_40", _$jscmd("src/taggle.js", "cond", "406_16_18", _isConfirmKey(key)) && _$jscmd("src/taggle.js", "cond", "406_38_18", input.value !== ""))) {
                _$jscmd("src/taggle.js", "line", 407);
                _confirmValidTagEvent(e);
                _$jscmd("src/taggle.js", "line", 408);
                return;
            }
            if (_$jscmd("src/taggle.js", "cond", "411_16_17", tag.values.length)) {
                _$jscmd("src/taggle.js", "line", 412);
                _checkLastTag(e);
            }
        }
        /**
         * Runs all the events that need to run on keyup
         * @param  {Event} e
         */
        function _keyupEvents(e) {
            _$jscmd("src/taggle.js", "line", 421);
            e = _$jscmd("src/taggle.js", "cond", "421_16_1", e) || _$jscmd("src/taggle.js", "cond", "421_21_12", window.event);
            _$jscmd("src/taggle.js", "line", 423);
            input.classList.remove("taggle_back");
            _$jscmd("src/taggle.js", "line", 425);
            _setText(sizer, input.value);
        }
        /**
         * Confirms the inputted value to be converted to a tag
         * @param  {Event} e
         * @return {Boolean}
         */
        function _confirmValidTagEvent(e) {
            _$jscmd("src/taggle.js", "line", 434);
            e = _$jscmd("src/taggle.js", "cond", "434_16_1", e) || _$jscmd("src/taggle.js", "cond", "434_21_12", window.event);
            _$jscmd("src/taggle.js", "line", 436);
            _add(e);
            //prevents from jumping out of textarea
            if (_$jscmd("src/taggle.js", "cond", "439_16_16", e.preventDefault)) {
                _$jscmd("src/taggle.js", "line", 440);
                e.preventDefault();
            } else {
                _$jscmd("src/taggle.js", "line", 443);
                e.returnValue = false;
            }
        }
        /**
         * Approximates when the hidden input should break to the next line
         */
        function _listenForEndOfContainer() {
            _$jscmd("src/taggle.js", "line", 451);
            var width = sizer.getBoundingClientRect().width, max = measurements.container.rect.width - measurements.container.padding, size = parseInt(sizer.style.fontSize, 10);
            //1.5 just seems to be a good multiplier here
            if (_$jscmd("src/taggle.js", "cond", "456_16_54", width + size * 1.5 > parseInt(input.style.width, 10))) {
                _$jscmd("src/taggle.js", "line", 457);
                input.style.width = max + "px";
            }
        }
        function _createTag(text) {
            _$jscmd("src/taggle.js", "line", 462);
            var li = document.createElement("li"), close = document.createElement("a"), hidden = document.createElement("input"), span = document.createElement("span");
            _$jscmd("src/taggle.js", "line", 467);
            text = text.toLowerCase();
            _$jscmd("src/taggle.js", "line", 469);
            close.href = "javascript:void(0)";
            _$jscmd("src/taggle.js", "line", 470);
            close.innerHTML = "&times;";
            _$jscmd("src/taggle.js", "line", 471);
            close.className = "close";
            _$jscmd("src/taggle.js", "line", 472);
            close.onclick = _remove.bind(null, close);
            _$jscmd("src/taggle.js", "line", 474);
            _setText(span, text);
            _$jscmd("src/taggle.js", "line", 475);
            span.className = "taggle_text";
            _$jscmd("src/taggle.js", "line", 477);
            li.className = "taggle " + settings.additionalTagClasses;
            _$jscmd("src/taggle.js", "line", 479);
            hidden.type = "hidden";
            _$jscmd("src/taggle.js", "line", 480);
            hidden.value = text;
            _$jscmd("src/taggle.js", "line", 481);
            hidden.name = settings.hiddenInputName;
            _$jscmd("src/taggle.js", "line", 483);
            li.appendChild(span);
            _$jscmd("src/taggle.js", "line", 484);
            li.appendChild(close);
            _$jscmd("src/taggle.js", "line", 485);
            li.appendChild(hidden);
            _$jscmd("src/taggle.js", "line", 487);
            tag.values.push(text);
            _$jscmd("src/taggle.js", "line", 488);
            tag.elements.push(li);
            _$jscmd("src/taggle.js", "line", 490);
            return li;
        }
        /**
         * Removes tag from the tags collection
         * @param  {li} li List item to remove
         * @param  {Event} e
         */
        function _remove(li, e) {
            _$jscmd("src/taggle.js", "line", 499);
            var span, text;
            if (_$jscmd("src/taggle.js", "cond", "502_16_33", li.tagName.toLowerCase() !== "li")) {
                _$jscmd("src/taggle.js", "line", 503);
                li = li.parentNode;
            }
            _$jscmd("src/taggle.js", "line", 506);
            span = li.querySelector(".taggle_text");
            _$jscmd("src/taggle.js", "line", 507);
            text = _$jscmd("src/taggle.js", "cond", "507_19_14", span.innerText) || _$jscmd("src/taggle.js", "cond", "507_37_16", span.textContent);
            _$jscmd("src/taggle.js", "line", 509);
            settings.onTagRemove(e, text);
            _$jscmd("src/taggle.js", "line", 511);
            li.parentNode.removeChild(li);
            _$jscmd("src/taggle.js", "line", 512);
            _removeFromTheTags(li, tag);
            _$jscmd("src/taggle.js", "line", 514);
            _focusInput();
        }
        _$jscmd("src/taggle.js", "line", 517);
        self.getTags = function() {
            _$jscmd("src/taggle.js", "line", 518);
            return tag;
        };
        _$jscmd("src/taggle.js", "line", 521);
        self.getTagElements = function() {
            _$jscmd("src/taggle.js", "line", 522);
            return tag.elements;
        };
        _$jscmd("src/taggle.js", "line", 525);
        self.getTagValues = function() {
            _$jscmd("src/taggle.js", "line", 526);
            return tag.values;
        };
        _$jscmd("src/taggle.js", "line", 529);
        self.getInput = function() {
            _$jscmd("src/taggle.js", "line", 530);
            return input;
        };
        _$jscmd("src/taggle.js", "line", 533);
        self.getContainer = function() {
            _$jscmd("src/taggle.js", "line", 534);
            return container;
        };
        _$jscmd("src/taggle.js", "line", 537);
        self.add = function(text) {
            _$jscmd("src/taggle.js", "line", 538);
            var is_arr = _isArray(text);
            if (_$jscmd("src/taggle.js", "cond", "540_16_24", typeof text === "string")) {
                _$jscmd("src/taggle.js", "line", 541);
                return _add(null, text);
            }
            if (_$jscmd("src/taggle.js", "cond", "544_16_6", is_arr)) {
                for (var i = 0, len = text.length; i < len; i++) {
                    if (_$jscmd("src/taggle.js", "cond", "546_24_27", typeof text[i] === "string")) {
                        _$jscmd("src/taggle.js", "line", 547);
                        _add(null, text[i]);
                    }
                }
            }
            _$jscmd("src/taggle.js", "line", 552);
            return self;
        };
        _$jscmd("src/taggle.js", "line", 555);
        self.remove = function(text, all) {
            _$jscmd("src/taggle.js", "line", 556);
            var len = tag.values.length - 1, found = false;
            while (len > -1) {
                if (_$jscmd("src/taggle.js", "cond", "560_20_24", tag.values[len] === text)) {
                    _$jscmd("src/taggle.js", "line", 561);
                    found = true;
                    _$jscmd("src/taggle.js", "line", 562);
                    _remove(tag.elements[len]);
                }
                if (_$jscmd("src/taggle.js", "cond", "565_20_13", _$jscmd("src/taggle.js", "cond", "565_20_5", found) && _$jscmd("src/taggle.js", "cond", "565_29_4", !all))) {
                    _$jscmd("src/taggle.js", "line", 566);
                    break;
                }
                _$jscmd("src/taggle.js", "line", 569);
                len--;
            }
            _$jscmd("src/taggle.js", "line", 572);
            return self;
        };
        _$jscmd("src/taggle.js", "line", 576);
        // Bang bang bang skeet skeet
        _init();
    };
    function _extend() {
        if (_$jscmd("src/taggle.js", "cond", "581_12_20", arguments.length < 2)) {
            _$jscmd("src/taggle.js", "line", 582);
            return;
        }
        _$jscmd("src/taggle.js", "line", 584);
        var master = arguments[0];
        for (var i = 1, l = arguments.length; i < l; i++) {
            _$jscmd("src/taggle.js", "line", 586);
            var object = arguments[i];
            for (var key in object) {
                if (_$jscmd("src/taggle.js", "cond", "588_20_26", object.hasOwnProperty(key))) {
                    _$jscmd("src/taggle.js", "line", 589);
                    master[key] = object[key];
                }
            }
        }
        _$jscmd("src/taggle.js", "line", 594);
        return master;
    }
    function _isArray(arr) {
        if (_$jscmd("src/taggle.js", "cond", "598_12_13", Array.isArray)) {
            _$jscmd("src/taggle.js", "line", 599);
            return Array.isArray(arr);
        }
        _$jscmd("src/taggle.js", "line", 601);
        return Object.prototype.toString.call(arr) === "[object Array]";
    }
    /**
     * Grabs the text from the li item and removes it from global array
     * @param  {Element} el
     */
    function _removeFromTheTags(el, tag) {
        _$jscmd("src/taggle.js", "line", 609);
        var elem = el.tagName.toLowerCase() === "a" ? _$jscmd("src/taggle.js", "cond", "609_56_13", el.parentNode) : _$jscmd("src/taggle.js", "cond", "609_72_2", el), index = tag.elements.indexOf(elem);
        _$jscmd("src/taggle.js", "line", 613);
        // Going to assume the indicies match for now
        tag.elements.splice(index, 1);
        _$jscmd("src/taggle.js", "line", 614);
        tag.values.splice(index, 1);
    }
    function _on(element, eventName, handler) {
        if (_$jscmd("src/taggle.js", "cond", "618_12_24", element.addEventListener)) {
            _$jscmd("src/taggle.js", "line", 619);
            element.addEventListener(eventName, handler, false);
        } else if (_$jscmd("src/taggle.js", "cond", "621_17_19", element.attachEvent)) {
            _$jscmd("src/taggle.js", "line", 622);
            element.attachEvent("on" + eventName, handler);
        } else {
            _$jscmd("src/taggle.js", "line", 625);
            element["on" + eventName] = handler;
        }
    }
    function _trim(str) {
        _$jscmd("src/taggle.js", "line", 630);
        return str.replace(/^\s+|\s+$/g, "");
    }
    function _setText(el, text) {
        if (_$jscmd("src/taggle.js", "cond", "634_12_46", _$jscmd("src/taggle.js", "cond", "634_12_18", window.attachEvent) && _$jscmd("src/taggle.js", "cond", "634_34_24", !window.addEventListener))) {
            _$jscmd("src/taggle.js", "line", 635);
            // <= IE8
            el.innerText = text;
        } else {
            _$jscmd("src/taggle.js", "line", 638);
            el.textContent = text;
        }
    }
    _$jscmd("src/taggle.js", "line", 642);
    window.Taggle = Taggle;
})(window, document);